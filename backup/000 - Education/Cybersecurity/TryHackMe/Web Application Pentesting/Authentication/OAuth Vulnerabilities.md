#OAuth #Authentication #webhacking #bugbounty #tryhackme 
# Introduction

In modern web applications, OAuth vulnerabilities emerge as a serious and frequently disregarded risk; when we talk about OAuth, we're talking about **OAuth 2.0**, the commonly used authorization framework. The vulnerabilities occur when hackers take advantage of weaknesses in OAuth 2.0, which allows for CSRF, XSS, data leakage and exploitation of other vulnerabilities.
## Learning Objectives

Throughout this room, you will gain a comprehensive understanding of the following key concepts:

- Essential concepts for OAuth 2.0 (Grant Types)  
- OAuth 2.0 flow
- Identify OAuth services
- Exploitation techniques
- Evolution of OAuth 2.1

An understanding of the following topics is recommended before starting the room:

- [OWASP Top 10](https://tryhackme.com/room/owasptop10)
- [ProtocolsÂ & Servers](https://tryhackme.com/room/protocolsandservers)
- [How Websites Work](https://tryhackme.com/room/howwebsiteswork)

Let's begin!
# Key Concepts

This task will discuss the key concepts for understanding OAuth, specifically OAuth 2.0. These concepts from the foundation for understanding how the OAuth 2.0 framework was built. As a pentester or secure coder, it is essential to understand these concepts to pentest a website or write code without a vulnerability. To make these concepts more relatable, we will explain them through a daily routine example: using a coffee shop's mobile app to order and pay for coffee.
## Resource Owner

The resource owner is the **person** or **system** that controls certain data and can authorize an application to access that data on their behalf. This concept is fundamental as it centers around *user content and control*. For example, you are the resource owner as a coffee shop customer. You can control your account information and grant the coffee shop's mobile app permission to access your data. 
## Client

The client can be a **mobile app** or a **server-side application**. It acts as an intermediary, requesting access to resources and performing actions as permitted by the resource owner. For example, the coffee shop's web app, which you use to order and pay for coffee, is the client. Your authorization is needed to access your account details and payment information.
## Authorization Server

The authorization server is responsible for **issuing access tokens to the client** after successfully authenticating the resource owner and obtaining their authorization. The authorization servers plays a crucial role in the OAuth process by ensuring the client is granted permission only after legitimate user authentication and consent. For example, the coffee shop's backend system handles authentication and authorization is the ***authorization server***. It verifies your credentials and grants the web app permissions to access your account. 
## Resource Server

The server hosting the protected resources can **accept and respond to protected resource**
**requests** using access tokens. This server ensures that *only authenticated and authorized* clients can access or manipulate the resource owner's data. For example, the resource server is the coffee shop's database that stores your account information, order history, and payment details. It responds to requests from the web app, allowing it to retrieve and modify your data.
## Authorization Grant

The client uses a credential representing the resource owner's authorization (to access their protected resources) to obtain an access token. The primary grant types are `Authorization Code`, `Implicit`, `Resource Owner Password Credentials`, and `Client Credentials`. For example, when you first log in to the coffee shop's app, you are given an authorization grant (like entering your username and password). The app uses this grant to get an access token from the authorization server. We will discuss it in detail in the next task.
## Access Token

A credential that the client can use the accessed protected resources on behalf of the resource owner. It has a **limited lifespan and scope**. Access tokens are essential for maintaining secure and protected communication between the client and resource server without repeatedly asking the resource owner for credentials. For example, once you log in to the coffee shop's app, it receives an access token, which allows the app to access your account to place orders and make payments without asking you to log in again for a specific period. 
## Refresh Token

A credential that the client can use to obtain a new access token without requiring the resource owner to re-authenticate. Refresh tokens are typically *long-lived* and provide a way to maintain user sessions without frequent login interruptions. For example, when your access token expires the web app will use a **refresh token** to get **a new access token**, so you don't have to log in again.
## Redirect URI

The URI to which the authorization server will redirect the resource owner's `user-agent` after the grant or denial of the authorization. It checks if the client for which the authorization response has been requested is correct. For instance, after interacting with the coffee shop app and logging in, you will be redirected to the authorization server by thee app page in the coffee shop's app, commonly known as the redirect URI, to confirm that you successfully logged in.
## Scope

Scopes are a mechanism for limiting an application's access to a user's account. They allow the client to specify the level of access needed and the authorization server to inform the user what access levels the application is requesting. Scopes help enforce the `principle of least privilege`.  For example, the coffee shop's app may request different scopes, such as access to your order history and payment details. As the resource owner, you can see what information the app requests access to and grant or deny permissions.
## State Parameter

An **optional** parameter maintains the state between the client and the authorization server. It can help prevent CSRF attacks by ensuring the response matches the client's request. The state parameter is  *crucial part of securing the OAuth flow*. 
	For example, when you initiate the login process, the coffee shop's app sends a state parameter to the authorization server. This parameter helps ensure that the response you receive is linked to your original request, protecting against certain types of attacks.
## Token & Authorization Endpoint

The authorization server's endpoint is where the client exchanges the authorization grant (or refresh token). In contrast, the authorization endpoint is where the resource owner is authenticated and authorizes the client to access the protected resources. 

By familiarizing yourself with the topics, you will easily understand the exploitation techniques and associated vulnerabilities in the upcoming tasks.
# OAuth Grant Types

OAuth 2.0 provides several grant types to accommodate various scenarios and client types. These grant types define how an application can obtain an access token to access protected resources on behalf of the resource owner. In this task, we will discuss four primary OAuth 2.0 grant types.
## Authorization Code Grant

The Authorization Code grant is the most commonly used OAuth 2.0 flow suited for server-side applications (PHP, JAVA, .NET etc). In this flow, the **client redirects the user to the authorization** 
**server, where the user authenticates and grants authorization**. The authorization server then redirects the user to the client with an **authorization code**. The client exchanges the authorization code for an access token by requesting the authorization server's token endpoint.

![](https://i.imgur.com/OlxLme0.png)

This grant type is known for its *enhanced security*, as the authorization code is exchanged for an access token server-to-server, meaning the access token is not exposed to the user agent (e.g. browser), thus reducing the risk of token leakage. It also supports using refresh tokens to maintain long-term access without repeated user authentication.
## Implicit Grant

The Implicit Grant is primarily designed for *mobile and web applications* where clients cannot securely store secrets. It **directly issues the access token to the client without requiring**
**an authorization code exchange**. In this flow, the client redirects the user to the authorization server. After the user authenticates and grants authorization, the authorization server returns an access **token in the URL fragment**. The complete flow is shown below:

![](https://i.imgur.com/TYULv96.png)

> This grant type is simplified and suitable for clients who cannot securely store client secrets. It is faster as it involves fewer steps than the authorization code grant. However, it is *less secure* as the access token is *exposed to the user agent and can be logged in the browser history*. It also **does**
> **not support refresh tokens**.
## Resource Owner Password Credentials Grant

The Resource Owner Password Credentials grant is used when the client is **highly trusted by the resource owner**, such as first-party applications. The client collects the user's credentials (username and password) directly and exchanges them for an access token, as shown below:

![](https://i.imgur.com/iVsPnDl.png)

In this flow, the user provides their credentials directly to the client. The client then sends the credentials to the authorization server, which verifies the credentials and issues an access token. This grant type is *direct*, requiring *fewer interactions*, making it suitable for highly trusted applications where the user is confident in providing their credentials. 
	However, it is less secure because it involves sharing credentials directly with the client and is unsuitable for third-party applications.
## Client Credentials Grant

The **Client Credentials** grant is used for server-to-server interactions without user involvement. The client uses his credentials to authenticate with the authorization server and obtain an access token. In this flow, the client authenticates with the authorization server using its client credentials (client ID and secret), and the authorization server issues an access token directly to the client, as shown below:

![](https://i.imgur.com/tRkL1gg.png)

This grant type is suitable for backend services and server-to-server communication as it does not involve user credentials, thus reducing security risks related to user data exposure. 

The next task will show how the OAuth flow works within a web application.
# How OAuth Flow Works

The OAuth 2.0 flow begins when a user (Resource Owner) interacts with a client application (Client) and requests access to a specific resource. The client redirects the user to an authorization server, where the user is prompted to log in and grant access. If the user consents, the authorization server issues an authorization code, which the client can exchange for an access token. This access token allows the client to access the resource server and retrieve the requested resource on behalf of the user.

![](https://i.imgur.com/BlWRsNW.png)

We will discuss the various steps of OAuth workflow in detail, considering the same `CoffeeShopApp` example.

We will use a customized version of the Django OAuth toolkit for the OAuth provider. It is very important to understand that when the term OAuth provider is used in the upcoming tasks, it means the **third-party OAuth provider with which we want to integrate/authenticate**.

For example, in the case of `Login With Factbook`, Factbook is the OAuth provider. Moreover, in these tasks, the OAuth provider, the `CoffeeShopApp`, would remain the same; however, the clients (the app we want to integrate) will change in each task. 

You can visit the URLÂ [http://coffee.thm:8000/admin](http://coffee.thm:8000/admin)Â to see the login panel for the OAuth provider, which would remain the same throughout the room.

We will be using the following credentials for the OAuth provider in this room:

- **Victim**: `victim:victim123`
- **Attacker**: `attacker:tesla@123`

**Note**: You are not required to log in at this stage, but later in this task, you can use any of the above credentials to log in.

Once logged in to the OAuth provider, you can log in on any other website just like your perform `Sign Up with Google` on X, Facebook, or any other website.

Now visit the URLÂ  [http://bistro.thm:8000](http://bistro.thm:8000), which we will use to understand the OAuth workflow. We will understand the workflow by considering a person named Tom (you can use any of the above credentials for him) who would like to log in to a different website app using his `CoffeeShopApp` account.

Tom first visits the bistro URLÂ  [http://bistro.thm:8000/oauthdemo](http://bistro.thm:8000/oauthdemo), where he wants to log in via `CoffeeShopApp`. When he clicks on **Login via OAuth**, `CoffeeShopApp` must first obtain his permission, so the application redirects Tom's browser to the authorization server with an authorization request.

Click on **Login with OAuth**, and you will be redirected to the authorization server with the URLÂ `http://coffee.thm:8000/accounts/login/?next=/o/authorize/%3Fclient_id%3Dzlurq9lseKqvHabNqOc2DkjChC000QJPQ0JvNoBt%26response_type%3Dcode%26redirect_uri%3Dhttp%3A//bistro.thm%3A8000/oauthdemo/callback`Â Â as shown below:

![](https://i.imgur.com/0n8D51H.png)

The bistro website initiates this process by redirecting Tom to the authorization server with the following parameters included in the URL:

- `response_type=code`: This indicates that `CoffeeShopApp` is expecting an authorization code in return.
- `state`: A CSRF token to ensure that the request and response are part of the same transaction.
- `client_id`: A public identifier for the client application, uniquely identifying `CoffeeShopApp`.
- `redirect_url`: The URL where the authorization server will send Tom after he grants permission. This must match one of the pre-registered redirect URIs for the client application.
- `scope`: Specifies the level of access requested, such as viewing coffee orders. 

By including these parameters, the bistro app ensures that the authorization server understands what is requested and where to send the user afterwards. Here is the Python code that redirects the user to the authorization server:

```python
def oauth_login(request):
	app = Application.objects.get(name="CoffeApp")
	redirect_uri = request.GET.get("redirect_uri", "http://bistro.thm:8000/oauthdemo/callback)

	authorization_url = (
		f"http://coffee.thm:8000/o/authorize/?client_id={app.client_id}&response_type=code&redirect_uri={redirect_uri}"
	)
	return redirect(authorization_url)
```
## Authentication & Authorization

When Tom reaches the authorization server, he is prompted to log in using his credentials. This step ensures that the server can verify his identity. After successfully logging in, the authorization server asks Tom if he agrees to grant the Bistro app access to his details. This consent step is crucial as it gives Tom transparency and control over which applications can access his data. 

The process typically involves:

- **User Login**: Tom enters his username and password on the authorization server's login page.
- **Consent Prompt**: After authentication, the authorization server presents Tom with a consent screen detailing what `CoffeeShopApp` requests access to (e.g. viewing his coffee orders). Tom must then decide whether to grant or deny these permissions.

![](https://i.imgur.com/YBSsAMq.png)

This dual step process ensures that Tom's identity is authenticated and his explicit consent is obtained before any access is granted, maintaining security and user control over personal data. 
## Authorization Response

If Tom agrees to grant access, the authorization server generates an **authorization code** (as also discussed in Task 4). The server then redirects Tom to the bistro website using the specified `redirect_uri`. The redirection includes the authorization code and the original state parameter to ensure the integrity of the flow. 

The authorization server responds with the following:

- `code:CoffeeShopApp` will use the authorization code to request an access token
- `state`: The CSRF token previously sent by `CoffeeShopApp` to validate the response. 

An example authorization response would be `https://bistro.thm:8000/callback?code=AuthCode123456&state=xyzSecure123`.

This step ensures the authorization process is secure and the response is linked to the bistro's initial request. The authorization code is a temporary token that will be used in the next step to obtain an access token, allowing `CoffeeShopApp` to access Tom's profile details.
## Token Request

The bistro website exchanges the authorization code for an access token by requesting the authorization server's token endpoint through a `POST` request with the following parameters:

- `grant_type`: type of grant being used; usually, it's set as `code` to specify authorization code as the grant type.
- `code`: the authorization code received from the authorization server.
- `redirect_uri`: this must match the original redirect URI provided in the authorization request.
- `client_id` and `client_secret`: credentials for authenticating the client application

Using the above parameters, the following code will make a token request to `/o/token` endpoint.

```python
token_url = "http://coffee.thm:8000/o/token/"
	client_id = Application.objects.get(name="CoffeeApp").client_id
	client_secret = Application.objects.get(name="CoffeeApp").client_secret
	redirect_uri = request.GET.get("redirect_uri", "http://bistro.thm:8000/oauthdemo/callback")

	data = {
		"grant_type": "authorization_code",
		"code": code,
		"redirect_uri": redirect_uri,
		"client_id": client_id
		"client_secret": client_secret
	}

	headers = {
		'Content-Type': 'application/x-www-form-urlencoded',
		'Authorization': f'Basic {base64.b64encode(f
		"{client_id}:{client_secret}".encode(().decode()},

	response = requests.post(token_url, data=data, headers=headers)
	tokens = response.json()
```

The bistro app securely exchanges the authorization code for an access token by sending this request. The authorization server will verify the information provided, ensuring the request is valid and originates from the client requesting the authorization code. If everything is correct, the authorization server will respond with the access token, allowing the bistro website to proceed with accessing Tom's profile details.
## Token Response

The authorization server authenticates the bistro website and validates the authorization code. Upon successful validation, the server responds with an `Access Token` and, optionally, a `Refresh Token`. 

The authorization server's response includes the following:

- `access_token`: Token that will be used to access Tom's details.
- `token_type`: Typically "Bearer".
- `expires_in`: The duration in seconds for which the access token is valid.
- `refresh_token` (optional): A token used to obtain new access tokens without requiring the user to log in again. 

With the access token, the bistro website can now authenticate requests to the resource server to access Tom's profile details. The optional refresh token can be used to request a new access token once the current one expires, providing a seamless user experience by avoiding the need for Tom to log in repeatedly. 

The bistro website has completed the OAuth 2.0 authorization workflow with the access token. This token is a credential allowing the app to access protected resources on Tom's behalf. Now, the bistro website can make authenticated requests to the resource server to retrieve Tom's profile. Each request to the resource server includes the **access token** in the authorization header, ensuring that the server recognizes and permits the access.

