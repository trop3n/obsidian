---
title: Introduction to Malware & Malware Analysis
tags:
  - malware
  - malwareanalysis
  - certifieddefensivesecurityanalyst
  - "#hackthebox"
  - windows
  - DFIR
author:
  - Hack the Box Academy
source: https://academy.hackthebox.com/module/227/section/2492
---
# Related Files

> [[Intro to Malware Analysis]] | [[So, You Wanna Write Malware]] | [[Windows Forensics 1]]
# [Malware & Malware Analysis](https://academy.hackthebox.com/module/227/section/2492)

> [!Important] 
> It is essential to clarify that this module does not claim to be an all-encompassing or exhaustive program on Malware Analysis. This module provides a robust foundation for SOC analysts, enabling them to confidently tackle key Malware Analysis tasks. The primary focus of the module will be the analysis of malware targeting the Windows Operating System.
## Malware Definition

`Malware`, short for **malicious software**, is a term encompassing various types of software designed to infiltrate, exploit, or damage computer systems, networks, and data.

Although all malware is utilized for malicious intents, the specific objectives of malware can vary among different threat actors. These objectives commonly fall into several categories:

- Disrupting host system operations. 
- Stealing critical information, including personal and financial data
- Gaining unauthorized access to systems
- Conducting espionage activities
- Sending spam messages
- Utilizing the victim's system for Distributed Denial of Service (DDoS) attacks
- Implementing ransomware to lock up a victim's files on their host and demanding ransom
## Malware Types

In today's fast-paced world of cyber threats, we find ourselves up against a broad spectrum of complex and varied malware forms, which pose a relentless challenge to our cyber defenses. It's paramount for us to grasp the multifaceted nature of malicious software as we endeavor to bolster the security of our systems and networks. Let's peel back the layers of some commonly seen types of malware that we frequently grapple with in our cybersecurity endeavors. 

- `Viruses`: These notorious forms of malware are designed to infiltrate and multiply within host files, transitioning from one system to another. They latch onto credible programs, springing into action when the infected files are triggered. Their destructive powers can range from corrupting or altering data to disrupting system functions, and even spreading through networks, inflicting widespread havoc. 
- `Worms`: Worms are autonomous malware capable of multiplying across networks without needing human intervention. They exploit network weaknesses to infiltrate systems without permission. Once inside, they can either deliver damaging payloads or keep multiplying to other vulnerable devices. Worms can initiate swift and escalating infections, resulting in enormous disruption and even potential denial of service attacks.
- `Trojans`: Also known as Trojan Horses, these are designed as genuine software to trick users into running them. Upon entering a system, they craft backdoors, allowing attackers to gain unauthorized control remotely. Trojans can be weaponized to pilfer sensitive data, such as passwords or financial information, and orchestrate other harmful activities on the compromised system.
- `Ransomware`: This malicious type of malware encrypts files on the target's system, making them unreachable. Attackers then demand a ransom in return for the decryption key, effectively holding the victim's data to ransom. The impacts of ransomware attacks can debilitate organizations and individuals alike, leading to severe financial and reputational harm.
- `Spyware`: This type of malware **stealthily gathers** sensitive data and user activities without their consent. It can trick online browsing habits, record keystrokes, and capture login credentials, posing a severe risk to privacy and security. The pilfered data is often sent to remote servers for harmful purposes. 
- `Adware`: Though not as destructive, adware can still be an annoyance and a security threat. It shows uninvited and invasive advertisements on infected systems, often resulting in a poor user experience. Adware may also track user behavior and collect data for targeted advertising.
- `Botnets`: These are networks of compromised devices, often referred to as bots or zombies, controlled by central command-and-control (C2) server. Botnets cna be exploited for a variety of harmful activities, including launching DDoS attacks, spreading spam, or disseminating other malware.
- `Rootkits`: These are stealthy forms of malware designed to gain unauthorized access and control over the fundamental components (the "root") of an operating system. They alter system functions to conceal their presences, making them extremely hard to spot and eliminate. Attackers can utilize rootkits to maintain prolonged access and dodge security protocols. 
- `Backdoors/RATs (Remote Access Trojans)`: Backdoors and RATs are crafted to offer unauthorized access and control over compromised systems for remote locations. Attackers can leverage them to retain prolonged control, extract data, or instigate additional attacks. 
- `Droppers`: These are a kind of malware used to transport and install extra malicious payloads onto infected systems. They serve as a conduit for other malware, ensuring the covert installation and execution of  more sophisticated threats.
- `Information Stealers`: These are tailored to target and extract sensitive data, like login credentials, personal information, or intellectual property, for harmful purposes. This includes identity theft or selling the data on the dark web.

These examples barely scratch the surface of malware we confront in today's threat landscapes. It's essential to remember that cybercriminals consistently confine their strategies, techniques and malware variants to avoid detection and exploit new vulnerabilities.
## Malware Samples

When it comes to enhancing our cybersecurity defenses and understanding the threats that exist, sometimes we have to dive into the dark corners of the cyber world. This means getting our hands on actual malware samples, be it for research, analysis, or educational purposes. However, it's crucial to emphasize that dealing with real malware samples should be done in a ***safe and controlled environment*** to prevent accidental infections and potential harm. Here are some resources, both free and paid, where we can find such samples.

- [VirusShare](https://virusshare.com/): An excellent resource for malware researchers, VirusShare houses a vast collection of malware samples. They currently have over 30 million samples in their repository, all of which are freely available to the public.
- [Hybrid Analysis](https://www.hybrid-analysis.com/): This website allows us to submit files for malware analysis. However, they also have a public feed of their analyses, where malware samples are often shared.
- [TheZoo](https://github.com/ytisf/theZoo): A GitHub repository that contains a collection of live malware for analysis and education. The repository also contains additional information about each sample, such as its family and the type of activities it performs.
- [Malware-Traffic-Analysis.net](https://malware-traffic-analysis.net/): This website provides traffic analysis exercises that can be extremely beneficial for people trying to learn about malware traffic patterns. They often provide pcap files of actual malware traffic, which can be quite informative.
- [VirusTotal](https://www.virustotal.com): VirusTotal inspects items with over 70 antivirus scanners and URL/domain blocklisting services, in addition to a myriad of tools to extract signals from the studied content. Any user can select a file from their computer using their browser and send it to VirusTotal. VirusTotal offers a number of file submission methods, including the primary public web interface, desktop uploaders, browser extensions and a programmatic API.
- [ANY.RUN](https://app.any.run/): An interactive online sandbox for malware analysis. The service allows researchers to analyze malware behavior by running samples in a controlled environment. While it offers both free and paid tiers, even the free version provides access to public submissions, which can include various malware samples.
- [Contagio Malware Dump](https://contagiodump.blogspot.com/): Contagio Dump is a collection of malware samples, threat reports, and related resources curated by a malware researcher named Mila. The site provides direct, anonymized access to an extensive range of malware samples, including various types of trojans, worms, ransomware, and exploits. It's frequently used by security researchers and analysts to study malware behavior and develop mitigation techniques.
- [VX Underground](https://www.vx-underground.org/): VX-Underground is one of the largest collections of malware source code, articles, and papers on the internet. It aims to collect, preserve, and share all kinds of materials related to malware, exploit, and hacking culture. This resource is valuable to security researchers and enthusiasts who want to study malware construction and behavior from a more technical and code-centric perspective.
## Malware/Evidence Acquisition

When it comes to gathering evidence during a digital investigation or incident reponse, having the right tools to perform disk imaging and memory acquisition is crucial. Let's discuss some free solutions we use to collect the necessary data for our investigations.
### Disk Imaging Solutions

- [FTK Imager](https://www.exterro.com/ftk-imager): Developed by AccessData (now acquired by Exterro), FTK Imager is one of the most widely used disk imaging tools in the cybersecurity field. It allows us to create perfect copies (or images) of computer disks for analysis, preserving the integrity of the evidence. It also lets us view and analyze the contents of data storage devices without altering the data.
- [OSFClone](https://www.osforensics.com/tools/create-disk-images.html): A free, open-source utility designed for the task of creating and cloning forensic disk images. It's easy to use and supports a wide variety of file systems.
- `DD and DCFLDD`: Both are command-line utilities available on Unix-based systems (including Linux and MacOS). DD is a versatile tool included in most Unix-based systems by default, while DCFLDD is an enhanced version of DD with features specifically useful for forensics, such as hashing.
### Memory Acquisition Solutions

- [DumpIt](https://www.magnetforensics.com/resources/magnet-dumpit-for-windows/): A simplistic utility that generates a physical memory dump of Windows and Linux machines. On Windows, it concatenates 32-bit and 64-bit system physical memory into a single output file, making it extremely easy to use.
- [MemDump](http://www.nirsoft.net/utils/nircmd.html): MemDump is a free, straightforward command-line utility that enables us to capture the contents of a system's RAM. It’s quite beneficial in forensics investigations or when analyzing a system for malicious activity. Its simplicity and ease of use make it a popular choice for memory acquisition.
- [Belkasoft RAM Capturer](https://belkasoft.com/ram-capturer): This is another powerful tool we can use for memory acquisition, provided free of charge by Belkasoft. It can capture the RAM of a running Windows computer, even if there's active anti-debugging or anti-dumping protection. This makes it a highly effective tool for extracting as much data as possible during a live forensics investigation.
- [Magnet RAM Capture](https://www.magnetforensics.com/resources/magnet-ram-capture/): Developed by Magnet Forensics, this tool provides a free and simple way to capture the volatile memory of a system.
- [LiME (Linux Memory Extractor)](https://github.com/504ensicsLabs/LiME): LiME is a Loadable Kernel Module (LKM) which allows the acquisition of volatile memory. LiME is unique in that it's designed to be transparent to the target system, evading many common anti-forensic measures.
### Other Evidence Acquisition Solutions

- [KAPE (Kroll Artifact Parser and Extractor)](https://www.kroll.com/en/services/cyber-risk/incident-response-litigation-support/kroll-artifact-parser-extractor-kape) ([[KAPE]]): KAPE is a triage program designed to help in collecting and parsing artifacts in a quick and effective manner. It focuses on targeted collection, reducing the volume of collected data and the time required for analysis. KAPE is free for use and is an essential tool in our digital forensics toolkit.
- [Velociraptor](https://github.com/Velocidex/velociraptor) ([[Velociraptor]]): Velociraptor is a versatile tool designed for host-based incident response and digital forensics. It allows for quick, targeted data collection across a wide number of machines. Velociraptor employs Velocidex Query Language (VQL), a powerful tool to collect and manipulate artifacts. The open-source nature of Velociraptor makes it a valuable free tool in our arsenal.
## Malware Analysis Definition, Purpose & Common Activities

The process of comprehending the behavior and inner working of malware is known as `Malware Analysis`, a crucial aspect of cybersecurity that aids in understanding the threat posed by malicious software and devising effective countermeasures.

In our pursuit of malware analysis, we delve into the malware's code, structure, and functionality to gain profound insights into it's purpose, propogation methods, and potential impact on targeted systems. 

By answering pertinent questions, such as:

- the type of malware (e.g. spybot, keylogger, ransomware)
- its intended behavior on endpoints
- the aftermath of its execution (including general artifacts on the network or endpoint and possible connections to Command and Control Servers)
- the extent of damage it can inflict,
- its attribution to specific threat groups 
- crafting detection rules based on the analysis to detect the malware across the entire network, we can devise mechanisms against these threats. 

Malware Analysis serves several pivotal `purposes`, such as: 

- `Detection and Classification`: Through analyzing malware, we can identify and categorize different types of threats based on their unique signatures, or patterns. This enables us to develop detection rules and empowers security professionals to gain a comprehensive understanding of the nature of the malware they encounter. 

- `Reverse Engineering`: Malware analysis often involves the intricate process of reverse engineering the malware's code to discern its underlying operations and employed techniques. This can unveil:
	- concealed functionalities,
	- encryption methods
	- details about the command-and-control infrastructure
	- techniques used for obfuscation and evasion

- `Behavioral Analysis`: By meticulously studying the behavior of malware during execution, we gain insights into its actions, such as modifications to the file system, network communications, changes to the system registry, and attempts to exploit vulnerabilities. This analysis provides invaluable information about the impact of the malware on infected systems and assists in devising potential countermeasures.

- `Threat Intelligence`: Through malware analysis, threat researchers can amass criticial intelligence about attackers, their tactics, techniques and procedures (TTPs), and the malware's origins. This valuable intelligence can be shared with the wider security community to enhance detection, prevention, and response capabilities.

The `Techniques` employed in malware analysts encompass a wide array of methods and tools, including:

- `Static Analysis`: This approach involves scrutinizing the malware's code without executing it, examining the file structure, identifying strings, searching for known signatures, and studying metadata to gain preliminary insights into the malware's characteristics.

- `Dynamic Analysis`: Dynamic analysis entails executing the malware within a controlled environment, such as a sandbox or virtual machine, to observe it's behavior and captures its runtime activities. This includes monitoring network traffic, system calls, file system modifications, and other interactions. 

- `Code Analysis`: Code analysis (includes reverse engineering) and involves disassembling or decompiling the malware's code to understand it's logic, functions, algorithms, and employed techniques. This helps in identifying concealed functionalities, exploitation methods, encryption methods, details about the command-and-control infrastructure, and techniques used for obfuscation and evasion. Inferentially, code analysis can also help in uncovering potential indicators of compromise. 

- `Memory Analysis`: Analyzing the malware's interactions with system memory helps in identifying injected code, hooks, or other runtime manipulations. This can be *instrumental* in detecting rootkits, analyzing anti-analysis techniques, or identifying malicious payloads.

- `Malware Unpacking`: This technique refers to the process of extracting and isolating the hidden malicious code within a piece of malware that uses **packing techniques** to evade detection. Packers are used by malware authors to compress, encrypt, or obfuscate their malicious code, making it harder for antivirus software and other security tools to identify the threat. Unpacking involves reverse-engineering these packing techniques to reveal the original, unobfuscated code for further analysis. This can allow researchers to understand the malware's functionality, behavior, and potential impact.

In today's ever-evolving threat landscape, the usage of malware analysis plays a pivotal role in our cybersecurity defense strategies. As cyber threats become increasingly sophisticated, we must continually enhance our capabilities to identify, analyze, and mitigate the risks posed by malicious software.

Through malware analysis, we gain *invaluable insights* into the nature of the threats we face. Understanding the malware's specific attributes allows us to tailor our response tactics accordingly, addressing each threat with precision.
# Windows Internals
> [[Core Windows Processes]] | [[Windows Forensics 1]] | [[Windows Forensics 2]]

To conduct effective malware analysis, a profound understanding of Windows internals is essential. Windows operating systems function in two main modes:

- `User Mode`: This mode is where most applications and user processes operate. Applications in user mode have limited access to system resources and must interact with the operating system through Application Programming Interfaces (APIs). These processes are isolated from each other and cannot directly access hardware or critical system functions. 
	- However, in this mode, malware can still manipulate files, registry settings, network connections, and other user-accessible resources, and it may attempt to escalate privileges to gain more control over the system.

- `Kernel Mode`: In contrast, kernel mode is a highly privileged mode where the Windows kernel runs. The kernal has **unrestricted access** to system resources, hardware, and critical functions. It provides code operating system services, manages system resources, and enforces security and stability. Device drivers, which facilitiate communication with hardware devices, also run in kernel mode. If malware operates in kernel mode, it gains elevated control and can manipualte system behavior, conceal it's presence, intercept system calls, and tamper with security mechanisms. 
## Windows Architecture at a High Level

The below image showcases a simplified version of Window's architecture.

![](https://i.imgur.com/7GXdXxm.png)

The simplified Windows architecture comprises both the user-mode and kernel-mode components, each with distinct responsibilities in the system's functioning.
## User-mode Components

`User-mode Components` are those parts of the operating system that don't have direct access to hardware or kernel data structures. They interact with system resources through APIs and system calls. Let's discuss some of them:

- `System Support Processes`: These are essential components that provide crucial functionalities and services such as logon processes (`winlogon.exe`), Session Manager (`smss.exe`), and Service Control Manager (`services.exe`). These aren't Windows services but they are necessary for the proper functioning of the system.

- `Service Processes`: These processes host Windows services like the `Windows Update Service`,`Task Scheduler`, and `Print Spooler` services. They usually run in the background, executing tasks according to their configuration and parameters. 

- `User Applications`: These are the processes created by user programs, including both 32-bit and 64-bit applications. They interact with the operating system through [APIs](https://en.wikipedia.org/wiki/Windows_API) provided by Windows. These API calls get redirected to [NTDLL.DLL](https://en.wikipedia.org/wiki/Microsoft_Windows_library_files#NTDLL.DLL), triggering a transition from user mode to kernel mode, where the system call gets executed. The result is then returned to the user-mode application, and a transition back to user mode occurs.

- `Environment Subsystems`: These components are responsible for providing execution environments for specific systems of applications or processes. They include the [Win32 Subsystem](https://en.wikipedia.org/wiki/Architecture_of_Windows_NT#Win32_environment_subsystem), [POSIX](https://en.wikipedia.org/wiki/Microsoft_POSIX_subsystem), and [OS/2](https://en.wikipedia.org/wiki/OS/2).

- `Subsystem DLLs`: These dynamic-link libraries translate documented functions into appropriate internal native system calls, primarily implemented in `NTDLL.DLL`. Examples include `kernelbase.dll`, `user32.dll`, `wininet.dll`, and `advapi32.dll`.
## Kernel Mode Components

`Kernel-mode Components` are those parts of the operating system that have direct access to hardware and kernel data structures. These include:

- `Executive`: This upper layer in the kernel mode gets access through functions from `NTDLL.DLL`. It consists of components like the `I/0 Manager`, `Object Manager`, `Security Reference Monitor`, `Process Manager`, and others, managing the core aspects of the operating system such as I/O operations, object management, security and processes. It runs some checks first, and then passes the called to kernel, or calls the appropriate device driver to perform the requested operation.

- `Kernel`: This component manages system resources, providing low-level services like `threat-scheduling`, `interrupt and exception dispatching`, and `multiprocessor synchronization`.

- `Device Drivers`: These software components enable the OS to interact with **hardware** **devices**. They serve as intermediaries, allowing the system to manage and control hardware and software resources. 

- `Hardware Abstraction Layer (HAL)`: This component provides an abstraction layer between the hardware devices and the OS. It allows software developers to interact with hardware in a consistent and platform-independent manner.

- `Windowing and Graphics System (Win32k.sys)`:  This subsystem is responsible for managing the graphical user interface (GUI) and rendering visual elements on the screen.

Now, let's discuss what happens behind the scenes when a user application calls a Windows API function.
## Windows API Call Flow

Malware often utilize Windows API calls to interact with the system and carry out malicious operations. By understanding the internal details of API functions, their parameters, and expected behavior, analysts can identify suspicious or unauthorized API usage. 

Let's consider an example of a Windows API call flow, where a user-mode application tries to access privileged operations and system resources using the [ReadProcessMemory function](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory). This function allows a process to read the memory of a different process.

![](https://i.imgur.com/9VrFLio.png)

When this function is called, some required parameters are also passed to it, such as the handle to the target process, the source address to read from, a buffer in its own memory space to store the read data, and the number of bytes to read. Below is the syntax of `ReadProcessMemory` WINAPI function as per Microsoft documentation.

```C++
BOOL ReadProcessMemory(
  [in]  HANDLE  hProcess,
  [in]  LPCVOID lpBaseAddress,
  [out] LPVOID  lpBuffer,
  [in]  SIZE_T  nSize,
  [out] SIZE_T  *lpNumberOfBytesRead
);
```

`ReadProcessMemory` is a WIndows API function that belongs to the `kernel32.dll` library. So, this call is invoked via the `kernel32.dll` module which serves as the user mode interface to the Windows API. Internally, the `kernel32.dll` module interacts with the `NTDLL.DLL` module, which provides a lower-level interface to the Windows kernel. Then, this function request is translated to the corresponding Native API call, which is `NtReadVirtualMemory`. The below screenshot from `x64gdb` demonstrates how this looks like in a debugger.

![](https://i.imgur.com/TetJ2Dw.png)

The `NTTDLL.DLL` module utilizes system calls (syscalls).

![](https://i.imgur.com/fqW4OLq.png)

The `syscall` instruction triggers the system call using the parameters set in the previous instructions. It transfers control from *user mode to kernel mode*, where the kernel performs the requested operation after validating the parameters and checking the access rights of the calling process. 

If the request is **authorized**, the thread is transitioned from user mode into the kernel mode. The kernel maintains a table known as the `System Service Descriptor Table (SSDT)` or the `syscall table (System Call Table)`, which is a data structure that contains pointers to the various system service routines. These routines are responsible for *handling system calls made by user-mode applications*. Each entry in the syscall table corresponds to a specific system call number, and the associated pointer points to the corresponding kernel function that implements the requested operation.

The syscall responsible for `ReadProcessMemory` is executed in the kernel, where the Windows memory management process isolation mechanisms are leveraged. The kernel performs necessary validations, access checks, and memory operations to read the memory from target process. The kernel retrieves the physical memory pages corresponding to the requested virtual addresses and copies the data into the provided buffer.

Once the kernel has finished reading the memory, it transitions the thread back to user mode and control is handed back to the original user mode application. The application can then access the data that was read from the target's process's memory and continue it's execution. 

> [!NOTE]
> Let's now navigate to the bottom of this section and click on "Click here to spawn the target system!". Then, let's RDP into the Target IP using the provided credentials. The vast majority of the actions/commands covered from this point up to end of this section can be replicated inside the target, offering a more comprehensive grasp of the topics presented.

```shell-session
trop3n@htb[/htb]$ xfreerdp /u:htb-student /p:'HTB_@cademy_stdnt!' /v:[Target IP] /dynamic-resolution
```
## Portable Executable

Windows operating systems employ the `Portable Executable (PE)` format to encapsulate executable programs, `DLLs (Dynamic Link Libraries)`, and other integral system components. In the realm of malware analysis, an intricate understanding of the PE file format is indispensable. It allows us to gain significant insights into the executable's structure, operations, and potential malign activities embedded within the file. 

PE files accommodate a wide variety of data types including `executables (.exe)`, `dynamic link libraries (.dll)`, `kernel modules (.srv)`, `control panel applications (.cpl)`, and many more. The PE file format is fundamentally a **data structure** containing the vital information required for the Windows OS loader to manage the executable code, effectively loading it into memory.
### PE Sections

The PE structure also houses a `Section Table`, an element comprising several sections dedicated to distinct purposes. The sections are essentially the repositories where the actual content of the file, including the data, resources utilized by the program, and executable code, is stored. The `.text` section is often under scrutiny for potential artifacts related to injection attacks. 

Common PE Sections include:

- `Text Section (.text)`: The hub where the executable code of the program resides.
- `Data Section (.data)`:  A storage for initialized global and static data variables.
- `Read-only initialized data (.rdata)`: Houses read-only data such as constant values, string literals, and initialized global and static variables. 
- `Exception information (.pdata)`: A collection of function table entries utilized for exception handling.
- `BSS Section (.bss)`: Holds uninitialized global and static data variables.
- `Resource Section (.rsrc)`: Safeguards resources such as images, icons, strings, and version information.
- `Import Section (.idata)`: Details about functions imported from other DLLs.
- `Export Section (.edata)`: Information about functions exported by the executable.
- `Relocation Section (.reloc)`: Details for relocating the executable's code and data when loaded at a different memory address.

We can visualize the sections of a portable executable using a tool like `pestudio` as demonstrated below.

![](https://i.imgur.com/cHGQrfO.png)

Delving into the Portable Executable (PE) file format is **pivotal** for malware analysis, offering insights into the file's:

- Structure
- Code Analysis
- Import and Export functions
- Resource Analysis
- Anti-Analysis techniques
- Extraction of IoCs

Our comprehension of this foundation paves the way for effacicious malware analysis.
## Processes

In the simplest terms, a process is an instance of an executing program. It represents a slice of a program's execution in memory and consists of various resources, including:

- Memory
- File Handles
- Threads
- Security Contexts

![](https://i.imgur.com/wwppRc9.png)

Each process is characterized by: 

- `A unique PID (Process Identifier)`: A unique **Process Identifier** (PID) is assigned to each process within the operating system. This numeric identifier facilitates the tracking and management of the process by the operating system.

- `Virtual Address Space (VAS)`: In the Windows OS, every process is allocated in it's own virtual address space, offering a virtualized view of the memory for the process. The VAS is sectioned into segments, including code, data and stack segments, allowing the process isolated memory access.

- `Executable Code (Image File on Disk)`: The executable code, or the image file, signifies the binary executable file stored on the disk. IT houses the instructions and resources necessary for the process to operate.

- `Tables of Handles to System Objects`: Processes maintain a table of handles, a reference catalogue for various system objects. System objects can span files, devices, registry keys, synchronization objects, and other resources.

- `Security Context (Access Token)`: Each process has a security context associated with it, embodied by an `Access Token`.  This `Access Token` encapsulates information about the process's security privileges, including the **user account** under which the process operates and the access rights granted to the process.

- `One or More Threads Running in its Context`: Processes consist of one or more threads, where a thread embodies a unit of execution within the process. Threads enable concurrent execution within the process and facilitate multitasking.
## Dynamic-Link Library (DLL)

A Dynamic-link library (DLL) is a type of PE which represents "Microsoft's implementation of the shared library concept in the Microsoft Windows OS". DLLs expose an array of functions which can be exploited by malware, which we'll scrutinize later. First, let's unravel the import and export functions in a DLL.
### Import Functions

- Import functions are functionalities that a binary dynamically links to from external libraries or modules during runtime. These function enable the binary to leverage the functionalities offered by these libraries.
- During malware analysis, examining import functions may shed light on the external libraries or modules that the malware is dependent on. This information aids in identifying the APIs that the malware might interact with, and also the resources such as the file system, processes, registry etc.
- By identifying specific functions imported, it becomes possible to ascertain the actions the malware can perform, such as file operations, network communication, registry manipulation, and more. 
- Import function names or hashes can serve as IoCs that assist in identifying malware variants or related samples.

Below is an example of identifying process injection using DLL imports and function names:

![](https://i.imgur.com/qkl0SqZ.png)

In this diagram, the malware process (`shell.exe`) performs process injection to inject code into a target process (`notepad.exe`) using the following functions imported from the DLL `kernel32.exe`.

- `OpenProcess`: Opens a handle to the target process (notepad.exe), providing the necessary access rights to manipulate its memory.
- `VirtualAllocEx`: Allocates a block of memory within the address space of the target process to store the injected code. 
- `WriteProcessMemory`: Writes the desired code into the allocated memory block of the target process.
- `CreateRemoteThread`: Creates a new thread within the target process, specifying the entry point of the injected code as the starting point.

As a result, the injected code is executed within the context of the target process by the newly created remote thread. This technique allows the malware to run arbitrary code within the target process.

The functions above are WINAPI (Windows API) functions. Don't worry about WINAPI functions as of now. We'll discuss these in detail later. 

We can examine the DLL imports of `shell.exe` (residing in the `C:\Samples\MalwareAnalysis` directory) using `CFF Explorer` ( available at `C:\Tool\Explorer Suite`) as follows:

![](https://i.imgur.com/JuBBI7m.jpeg)
### Export Functions

- Export functions are the functions that a binary exposes for use by other modules or applications.
- These functions provide an interface for other software to interact with the binary.

In the below screenshot, we can see an example DLL imports (using `CFF Explorer`) and exports (using `x64dbg - Symbols` tab)

- `Imports`: This shows the DLLs and their functions imported by an executable `Utilman.exe`
- `Exports`: This shows the functions exported by a DLL `kernel32.dll`.

![](https://i.imgur.com/vB3IxEa.png)

In the context of malware analysis, understanding import and export functions assists in discerning the behavior, capabilities, and interactions of the binary with external entities. It yields valuable information for threat detection, classification, and guaging the impact of the malware on the system.
# Static Analysis on Linux

In the realm of malware analysis, we exercise a method called static analysis to scrutinize malware without necessitating its execution. This involves the meticulous investigation of malware's code, data and structural components, serving as a vital precursor for further, more detailed analysis.


Through static analysis, we endeavor to extract pivotal information which includes:

- File type
- File hash
- Strings
- Embedded elements
- Packer information
- Imports
- Exports
- Assembly code

![](https://i.imgur.com/9vnsjkI.png)

> [!Exercise]
> Let's now navigate to the bottom section and click on "Click here to spawn the target system!". Then, let's SSH into the Target IP using the provided credentials. The vast majority of the actions/commands covered from this point up to end of this section can be replicated inside the target, offering a more comprehensive grasp of the topics presented.
## Identifying the File Type

Our first port of call in this stage is to ascertain the rudimentary information about the malware specimen to lay the groundwork for our investigation. Given that file extensions can be manipulated and changed, our task is to devise a method to identify the actual file type we are encountering. Establishing the file type plays an integral role in static analysis, ensuring that the procedures we apply are appropriate and the results obtained are accurate. 

Let's used a Windows-based malware named `Ransomware.wannacry.exe` residing in the `/home/htb-student/Samples/MalwareAnalysis` directory of this section's target as an illustration.

The command for checking the file type of this malware would be the following:

```shell
trop3n@htb[/htb]$ file /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
/home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe: PE32 executable (GUI) Intel 80386, for MS Windows
```

We can also do the same by manually checking the header with the help of the `hexdump` 
command as follows.

```shell
trop3n@htb[/htb]$ hexdump -C /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe | more
00000000  4d 5a 90 00 03 00 00 00  04 00 00 00 ff ff 00 00  |MZ..............|
00000010  b8 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00  |........@.......|
00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000030  00 00 00 00 00 00 00 00  00 00 00 00 f8 00 00 00  |................|
00000040  0e 1f ba 0e 00 b4 09 cd  21 b8 01 4c cd 21 54 68  |........!..L.!Th|
00000050  69 73 20 70 72 6f 67 72  61 6d 20 63 61 6e 6e 6f  |is program canno|
00000060  74 20 62 65 20 72 75 6e  20 69 6e 20 44 4f 53 20  |t be run in DOS |
00000070  6d 6f 64 65 2e 0d 0d 0a  24 00 00 00 00 00 00 00  |mode....$.......|
00000080  55 3c 53 90 11 5d 3d c3  11 5d 3d c3 11 5d 3d c3  |U<S..]=..]=..]=.|
00000090  6a 41 31 c3 10 5d 3d c3  92 41 33 c3 15 5d 3d c3  |jA1..]=..A3..]=.|
000000a0  7e 42 37 c3 1a 5d 3d c3  7e 42 36 c3 10 5d 3d c3  |~B7..]=.~B6..]=.|
000000b0  7e 42 39 c3 15 5d 3d c3  d2 52 60 c3 1a 5d 3d c3  |~B9..]=..R`..]=.|
000000c0  11 5d 3c c3 4a 5d 3d c3  27 7b 36 c3 10 5d 3d c3  |.]<.J]=.'{6..]=.|
000000d0  d6 5b 3b c3 10 5d 3d c3  52 69 63 68 11 5d 3d c3  |.[;..]=.Rich.]=.|
000000e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000000f0  00 00 00 00 00 00 00 00  50 45 00 00 4c 01 04 00  |........PE..L...|
00000100  cc 8e e7 4c 00 00 00 00  00 00 00 00 e0 00 0f 01  |...L............|
00000110  0b 01 06 00 00 90 00 00  00 30 38 00 00 00 00 00  |.........08.....|
00000120  16 9a 00 00 00 10 00 00  00 a0 00 00 00 00 40 00  |..............@.|
00000130  00 10 00 00 00 10 00 00  04 00 00 00 00 00 00 00  |................|
00000140  04 00 00 00 00 00 00 00  00 b0 66 00 00 10 00 00  |..........f.....|
00000150  00 00 00 00 02 00 00 00  00 00 10 00 00 10 00 00  |................|
00000160  00 00 10 00 00 10 00 00  00 00 00 00 10 00 00 00  |................|
00000170  00 00 00 00 00 00 00 00  e0 a1 00 00 a0 00 00 00  |................|
00000180  00 00 31 00 54 a4 35 00  00 00 00 00 00 00 00 00  |..1.T.5.........|
00000190  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
```

On a Windows system, the presence of the ASCII string `MZ` (in hexadecimal: `4D 5A`) at the start of a file (known as the **magic number**) denotes an executable file. `MZ` stands for Mark Zbikowski, a key architect of MS-DOS.
## Malware Fingerprinting

In this stage, our mission is to create a unique identifier for the malware sample. This typically takes the form of a cryptographic hash - MD5, SHA1, or SHA256.

Fingerpringting is employed for numerous purposes, encompassing:

- `Indentification and tracking of malware samples`
- `Scanning an entire system for the presence of identical malware`
- `Confirmation of previous encounters and analyses of the same malware`
- `Sharing with stakeholders as IoC (Indicators of Compromise)` or as part of threat intelligence reports. 

As an illustration, to check the MD5 file hash of the above-mentioned malware the command would be the following.

```shell-session
trop3n@htb[/htb]$ md5sum /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
db349b97c37d22f5ea1d1841e3c89eb4  /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
```

To check the SHA256 file hash of the above-mentioned malware the command would be the following.

```shell-session
trop3n@htb[/htb]$ sha256sum /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
24d004a104d4d54034dbcffc2a4b19a11f39008a575aa614ea04703480b1022c  /home/htb-student/Samples/MalwareAnalysis/Ransomware.wannacry.exe
```
## File Hash Lookup

The ensuing step involves checking the file hash produced in the prior step against online malware scanners and sandboxes such as Cuckoo sandbox. For instance, VirusTotal, an online malware scanning engine, which collaborates with various antivirus vendors, allows us to search for the file hash. This step aids us in comparing our results with existing knowledge about the malware sample. 

The following image displays the results from [VirusTotal](https://www.virustotal.com/gui/home/search) after the SHA256 file hash of the aforementioned malware was submitted.

![](https://i.imgur.com/sxUwt9r.png)

Even though a file hash like MD5, SHA1, or SHA256 is valuable for identifying identical samples with disparate names, it falls short when identifying similar malware samples. This is primarily because a malware author can alter the file hash value by making minor modifications to the code and recompiling it.

Nonetheless, there exist techniques that can aid in identifying similar samples:
### Import Hashing (IMPHASH)

`IMPHASH`, an abbreviation for "Import Hash", is a cryptographic hash calculated from the import functions of a Windows Portable Executable (PE) file. Its algorithm function names to lowercase. Following this, the DLL names and function names are fused together and arranged in alphabetical order. Finally, an MD5 hash is generated from the resulting string. Therefore, two PE files in 



