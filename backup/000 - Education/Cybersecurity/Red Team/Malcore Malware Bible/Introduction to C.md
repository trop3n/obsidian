---
up: "[[Malcore Malware Bible]]"
tags:
  - "#education/books/cybersecurity/redteam/malcore/introtoc"
prev: "[[Introduction to Python]]"
source: https://github.com/Perkins-Fund/Malcore-Free-Courses/tree/main
---


![](https://i.imgur.com/6VCOg7j.png)

https://bible.malcore.io/readme/the-beginning/introduction-to-c
# What Will be Covered?

- What is C?
- C Syntax and Structures
- Control Flows
- C Functions
- What the Fuck is A Pointer?
- Memory Overview
- Preprocessor Directives and Macros
- Debugging and Error Handling
- Writing a Program
- That's all!
# What is C?

In a sentence: C is a powerful general-purpose compiled programming language.

In a more descriptive way: C is a powerful compiled programming language that was developed by Dennis Ritchie in 1972 at Bell Labs. It was originally designed for systems programming specifically, operating systems.

Overtime C became one of the most widely used languages in existence and was used for a lot more than just operating system development. C is know for simplicity, efficiency and system resource control. It is a popular choice for applications that require high performance or low-level interaction. There are of course issues with C a lot of people consider it a "broken language" however, we will not get into that debate here.
## Issues and Benefits of C

It is good for you to understand the issues in C as well as the benefits. We will first start with the issues:

- Manual memory management and no garbage collection. Meaning that you must manage your own memory in your programs, it is not done for you like it is in other languages such as Python.
- Lack of object orientation. There is no OOP in C. Meaning it does not have classes in it.
- There is no built-in error handling. C relies on return codes and external error handling. 
- C's low-level access can provide security issues such as buffer overflows, stack overflows, and other security issues. These issues can be exploited if not carefully written.

The issues are descriptive and provide a good understanding of what's wring with the C language and what can arise for the developer. However, there are of course benefits of C such as:

- Efficiency and speed. C is highly efficient with minimal overtime runtime. Critical performance applications are ideal to write in C due to its direct memory access and low-level operation abilitites.
- C is very portable. It can be ported across multiple platforms easily.
- Simplicity. Despite how powerful C is, it is simple. There is a small number of keywords and the syntax is pretty straightforward.
- Extensiveness. There are millions of libraries for C that can do literally anything you can imagine. It's been around long enough that everything has been created. 
# Syntax and Structures

Now that you actually know what C is we should get to the basics of syntax and data structures. We will go through a breakdown of the syntax:

- Comments:
	- Single line comment example:

```C
// this is comment in C
```

- Multi line comment example:

```C
/*
	this is
	a
	multi line
	comment in C
*/
```

- Data types:
	- `int`: Integer values, IE: `int x = 5;`
	- `float`: floating point values, i.e.: `float pi = 3.14`
	- `double`: double floating point values: i.e.: `double pi = 3.14159;`
	- `char`: single character, i.e.: `char letter = 'A';`
	- `void`: signifies no value or empty set of values.
- Variables:
	- Variables must always be declared before use. For example:

```C
int a;
float b;
char c;
```

- It is also possible to initialize a variable upon use

```C
int a = 5;
char c = 'c';
float b = 1.5;
```

- Constants:
	- You can declare a constant using the `const` keyword. IE: `const int AGE = 33;`
	- You can also declare them using `#define`, IE `#define PI 3.14`
- Operators:
	- Arithmetic operators:
		- `+` addition
		- `-` subtraction
		- `*` multiplication
		- `/` division
		- `%` modulus
	- Comparison operators:
		- `==` equal to
		- `!=` not equal to
		- `>` greater than
		- `<` less than
		- `>=` greater than or equal to
		- `<=` less than or equal to
	- Logical operators:
		- `&&` logical AND o
		- `||` logical OR
		- `!` logical NOT
- Arrays:
	- Arrays allow you to store multiple values of the same type, i.e:
	- `int numbers[5] {1,2,3,4,5};`
- Structures (structs):
	- A structure (or struct) is a grouping of different data types. Example:

```C
struct Person {
  char name[50];
  int age;
  float height;
};

// create a person
struct Person john = {.name = "John", .age = 50, .height = 65.6};
```

- Enumerations (enums)L
	- An enumeration (enum) is a way to assign names to integer values. Example:

```C
enum Weekday {Monday, Tuesday};
enum Weekday today = Monday;
```

- Modifier:
	- C offers modifiers that can be applied to basic data types. It changes their range and size.
		- `signed`: can store both positive and negative integers, i.e. `signed int num = -5`
		- `unsigned`: can store only positive values, i.e. `unsigned int num = 15;`
		- `short`: reduces storage size, i.e. `short int num = 50;`
		- `long`: increases the storage size, i.e. `long int num = 100000;`
- Typedef:
	- Used to give a new name to an existing type
	- Size and basic data types are in the table below:

```C
typedef unsigned int uint;
unit x = 100;
```

| Data Type | Size (bytes) | Range (signed)                  | Range (unsigned)  | Note                                                       |
| --------- | ------------ | ------------------------------- | ----------------- | ---------------------------------------------------------- |
| `char`    | 1            | -128 - 127                      | 0 - 255           | `char` can be signed or unsigned depending on the compiler |
| `int`     | 4            | -2,147,483,648 to 2,147,483,647 | 0 - 4,294,967,295 | n/a                                                        |
| `float`   | 4            | 3.4E-38 - 3.4E+38               | n/a               | n/a                                                        |
| `double`  | 8            | 1.7E-308 - 1.7E+308             | n/a               | n/a                                                        |
## Controlling the Flow

Control flow is the orders that statements, instructions, or functions are executed or evaluated. There are several control flow options in C.

- Types of control flow:
	- `Conditional statements`: executes different code based on certain conditions.
	- `Loops`: repeat a block of code multiple times (or forever).
	- `Jump statements`: unconditional control transfer to another part of the program.
- Condition statements:
	- `if/else if/else` statement
		- This statements allows execution of a block of code `if` a specific condition is true. You may also use an `else if` to test multiple conditions to be true. Otherwise, the alternative block of code in the `else` is executed. Example:

```C
int x = 10;

if (x > 10) {
   printf("x is greater than 10");
} else if (x > 5) {
   printf("x is greater than 5 less than 10");
} else {
   printf("x is less than 5");
}
```

- Switch statements
	- Execute one block of code among multiple depending on the value of an expression. Switch statements have a `default` condition, this condition is executed if none of expressions match the case. Example:

```C
int day = 2;

switch (day) {
  case 1:
    printf("Monday");
  case 2:
    printf("Tuesday");
  case 3:
    printf("Wednesday");
  default:
    printf("That's not a fuckin day...");
}
```

-  Loops
	- `for` loop repeats a block of code a known number of times, i.e.

```C
for (int i - 0; i < 5; i++) {
  printf("%d", i);
}
```

- `while` loop is used to repeat code while a condition is evaluated to be true, i.e.:

```C
int 1 = 0;

while (i < 5) {
  printf("%d", i);
  i++
}
```

- `do-while` loop is similar to a while loop. However, the condition is checked AFTER the loop has already executed. This guarantees that the loop will run at least once, i.e:

```C
int = 0;

do {
  printf("%d". 1);
  i++;
} while (i < 5);
```

- Jump statements:
	- `break`: used to exit a loop prematurely regardless of condition, i.e:

```C
for (in i = 0; i < 5; i++) {
  if (i == 2) {
    break;
  }
  printf("%d", i);
}
```

- `continue`: skip current iteration and move to next, i.e.:

```C
for (in i = 0; i < 5; i++) {
  if (i == 2) {
    continue;
  }
  printf("%d", i);
}
```

- `goto`: allows you to jump to predefined labels within the program, i.e.

```C
int 1 = 0;

// label
start:
  printf("%d", i);
  i++;
  if (i < 3) {
    goto start:
  }
```

> [!NOTE]
> **Note**: it is worth noting that `goto` is usually frowned upon because it can make the code hard to follow. However, *do whatever you want*. It's your code. It is also worth noting that `goto` is useful for deep nested loops.

- Return statements:
	- Used to exit a function and return a value from that function call, i.e.:

```C
int add(int a, int b) {
  return a + b
}
```

> Summary of control flows cheat sheet:

| Contstruct | Type                  | Description                                                                             | Syntax |
| ---------- | --------------------- | --------------------------------------------------------------------------------------- | ------ |
| `if`       | Conditional Statement | Executes a block of code if the condition is true.                                      |        |
| `if-else`  | Conditional Statement | Executes one block of code if the condition is true, another if the condition is false. |        |
| `else-if`  | Conditional Statement | Tests multiple conditions sequentally.                                                  |        |
| `switch`   | Conditional Statement | Selects one block of code to execute from multiple options based on a variable's value. |        |
| `for`      | Loop                  | Repeats a block of code a specific number of times.                                     |        |
| `while`    | Loop                  | Repeats a block of code while a condition is true.                                      |        |
| `do-while` | Loop                  | Executes a block of code at least once while a condition is true.                       |        |
| `break`    | Jump Statement        | Exits from a loop or switch statement immediately.                                      |        |
| `continue` | Jump Statement        | Skips the current iteration of a loop and continues with the next iteration.            |        |
| `goto`     | Jump Statement        | Transfers control to a labeled part of the code. **Use is Discouraged**.                |        |
| `return`   | Function Control      | Exits a function and optionally returns a value to the calling function.                |        |
## C Functions

A function in C is a block of code that can be called multiple times throughout the program. Functions are usually designed to do one thing and do it well. This allows for easily readable code that provides **better maintainability**. It allows you to write a chuck of code one time and use it over and over again.

When declaring a function in C you use a `prototype`. You must declare a function *before* use. This is typically done before the `main` function of the program. The declaration informs the compiler about the name, return type, and parameters of the function.

The syntax of a function is: `return type function_name(parameters)`. As an example of a basic function:

```C
// create a function prototype
int add(int a, int b);
```

Function definitions specify the actual code that is executed within the function when it is called. This is a set of instructions that make up the functions logical body:

```C
int add(int a, int b) {
  return a + b;
}
```

Once the function has been declared and defined you can call the function by simply calling its name and passing the required arguments. For example:

```C
int result = add(1, 2);
// this returns 3
```

It is entirely possible to create a function that returns nothing. In order to do so you will provide it with the `void` return type:

```C
void logWelcome() {
  printf("Hey nerd!");
}
```

Recursion is when *a function calls itself*. This can be useful for solving problems without having to write extra code. For example:

```C
int factorial(int n);
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
```

> Notice how we recall the function from within itself. 

Key concept cheat sheet of functions:

| **Element**              | **Description**                                                                                   |
| ------------------------ | ------------------------------------------------------------------------------------------------- |
| **Function Declaration** | Specifies the function's name, return type, and parameters.                                       |
| **Function Definition**  | Contains the code (body) that performs the function's task.                                       |
| **Function Call**        | Invokes the function, passing the necessary arguments to the function.                            |
| **Return Type**          | Indicates the type of value the function returns (IE: `int`, `float`, `void` if no return value). |
| **Parameters**           | Inputs to the function, passed when calling the function.                                         |
| **Void Function**        | A function that performs an action but does not return any value.                                 |
| **Recursion**            | A function that calls itself for repetitive tasks.                                                |
## What the Fuck is a Pointer?

A pointer is a variable that stores the memory address of another variable. Instead of holding the value of the variable it "points to" the memory address where the values are stored. This provides a powerful way to *efficiently use memory manipulation* and is essential for things like dynamic memory allocation, arrays, and function calls. 
### Declaring a Pointer

To declare a pointer you specify the data type of the variable followed by an asterisk (`*`) and finally the pointer name:

```C
// data_type *pointer_name;
int *a;
```

- The `*a` indicates that the variable `a` is a pointer to an integer. 
- Initially the pointer will contain an arbitrary memory address and should be assigned a valid address before use.
### Initialize a Pointer

To initialize a pointer you assign the address of another variable using the *address of operator* (`&`).

```C
// pointer_name = &variable;
int x = 12;
int *p = &x; // this now holds the address of the 'x' variable
```

- The `x` variable stores the integer `12`
- The `p` stores the memory address of the `x` variable, but *not the value of it*.
### Dereference a Pointer

Dereferencing pointers is when you access the value stored at the memory address.

```C
// *pointer_name = &variable'
int x = 12;
int *p = &x;
printf("%d", *p); // Dereferencing: prints the value of 'x' which is 12.
```
### Null Pointers

Null pointers are a pointer that points to nothing or an invalid memory location. When you initialize a pointer, and it doesn't point to anything it is good practice to initialize it to null. 

```C
int *p NULL;
```

- This indicates that the pointer is not pointing to anything valid. 
### Arrays

An array acts as pointers to the first element in the array. You can use pointers to iterate through the array. This way you don't have to declare the pointer (`&`) for an array since it's already technically a pointer. 

```C
int arr[] = {10, 20, 30};
int *p = arr;
printf("%d", *p);  // output is 10
p++;
printf("%d", *p);  // output is 20
```

### Pointer Arithmetic

Pointer arithmetic is when you navigate through memory locations that are contiguous (such as arrays) using a pointer. 

You can increment and decrement a pointer in order to move to the next value.

```C
int arr[] = {10, 20, 30};
int *p = arr; // this pointer points to the first element of the array
arrP++;       // this pointer now points to the second value of the array
```

You can also add or subtract an integer to move the pointer by that many elements. 

```C
arrP = arrP + 2; // move by 2 elements
```

Using pointers with functions can allow you to modify a variable or array directly without returning a value.

```C
void incPointers(int *p) {
  (*p)++ // increment the value of the pointer
}

int main() {
  int x = 5;
  incPointer(&x);    // pass memory address of x variable
  printf("%d", x);   // should output 6
  return 0;
}
```
### Pointerception

C allows you to point to pointers, it's like pointerception but less cool and more confusing.

```C
// data type **pointer_name
int x = 10;           // create an integer variable with value 10
int *p = &x;          // create a pointer to that variable
int **pp = %p;        // do pointerception and confuse the fuck out of 
                     //    everyone

printf("%d", **pp);
```
### Downsides and Upsides of Pointers

There are of course downsides and upsides of pointers. We will start with the downsides:

- Pointers can become extremely complex and confusing. They can make your code extremely hard to read, understand, and debug.
- Incorrect use of pointers can lead to memory leaks, segmentation faults, and security vulnerabilities.

**Upsides of Pointers**:

- Pointers are very efficient at managing memory and allow dynamic memory allocation.
- They provide direct memory access that allows you to manipulate data at very low levels.
### Pointer Cheat Sheet

Key concepts to remember (cheat sheet):

| **Pointer Concept** | **Description**                                                                 | **Example**               |
| ------------------- | ------------------------------------------------------------------------------- | ------------------------- |
| Pointer Declaration | Declares a pointer to store the address of a variable.                          | `int *p;`                 |
| Pointer Initialized | Initializes a pointer by assigning the address of a variable.                   | `p = &x;`                 |
| Dereferencing       | Accesses the value stored at the memory address a pointer points to.            | `*p`                      |
| Null Pointer        | A pointer that points to nothing.                                               | `int *p = NULL;`          |
| Pointer Arithmetic  | Performing arithmetic operations on pointers (incrementing, decrementing, etc.) | `p++;`                    |
| Pointer to Array    | Points to the first element of an array, allowing easy array traversal.         | `int *p = arr;`           |
| Pointer to Function |                                                                                 | `void increment(int *p);` |
| Pointer to Pointer  | A pointer that points to another pointer                                        | `int **pp = &p;`          |
### How Not to Use a Pointer

As a bonus as mentioned earlier pointers can get extremely complex. So, we ill be showing you an example of a complex pointer and why you need to be careful when creating pointers and using them in your code. The code below should never be used in production, and never be used in anything. Read the comments to understand exactly what is going on:

```C
int main() {
  // declare an integer and set it to 42
  int x = 42;

  // create a pointer to that integer
  int *p = &x;

  // create a pointer to that pointer
  int **pp = &p;

  // create a pointer to that pointer to that pointer
  int ***ppp = &pp;

  // create a pointer to that pointer to that pointer to that 
  //  pointer
  int ****pppp = &ppp;

  // WTF AM I DOING
  // pointer arithmetic combined with dereferencing
  int *****ppppp = &pppp;

  // WHY DOES THIS WORK?!
  // modify x through absurd dererferencing and pointer arithmetic
  *****ppppp[0][0][0][0][0] = 99;

  // should print 99
  printf("x = %d\n", x);

  // same as above but WTF
  printf("x (via ppppp): %d\n", *****ppppp[0][0][0][0][0]);

  // get the addresses
  printf("Address of p: %p\n", *****ppppp[0][0][0][0]);
  printf("Address of pp: %p\n", *****ppppp[0][0][0]);
  printf("Address of ppp: %p\n", *****ppppp[0][0]);
  printf("Address of pppp: %p\n", *****ppppp[0]);
  return 0;
  }
```
## Memory Allocation

Memory allocation is the process of allocating and managing memory during the execution of a program. There are two main types of memory allocations in C:

- `Static Memory Allocation`: this memory is allocated at compilation time.
- `Dynamic Memory Allocation`: this memory is allocated dynamically at runtime using pointers.

There are several functions to perform memory management. They are:

- `malloc()`: allocates memory dynamically
	- Benefits:
		- Allows dynamic memory allocation making it possible to only allocate the memory you need.
		- Allows flexibility by providing the ability to allocate memory of any size.
		- Does not have any initialization overhead.
	- Issues:
		- The memory is not initialized and contain garbage values. This may lead to undefined behavior if the memory is accessed before initialized. 
		- Provides a risk of memory leaks if you don't `free()` the memory allocation.
		- Even though it's faster than `calloc()` you have to manually initialize it which adds additionally complexity. 
- `calloc()`: allocates memory an array and initializes to zero.
	 - Benefits:
			- Initializes all memory to zero.
			- Is designed for arrays which makes it easier to understand.
	- Issues:
			- Performance overhead because it is initialized to zero.
			- More complicated to use because it requires two arguments.
			- Can produce over allocation which can produce memory waste or crashes.
- `realloc()`: resizes previously allocated memory.
	- Benefits:
		- Allows you to resize memory allocation dynamically as long as that memory is already allocated. 
		- Will preserve existing data on resize.
	- Issues:
		- Does not expand the current block, just reloccates the existing block somewhere else. 
		- Has the potential for data loss. If it fails it will return `NULL`.
		- Has performance overhead because it has to move the memory to another location.
- `free()`: frees dynamically allocated memory.
	- Benefits:
		- Can help prevent memory leaks
		- Is a necessity for memory management in C.
	- Issues: 
		- If you free memory and continue to use a pointer without resetting it to `NULL`, it will become a dangling pointer. Dereferencing these pointers can lead to unexpected behavior.
		- If you call free on the same pointer more than once this may result in a `double free` which may lead to undefined behavior, crashes, and/or vulnerabilities.
		- If you forget to free dynamically allocated memory this will result in memory leaks.
### Static Memory Allocation

When you allocate memory statistically you determine the lifetime and size of the variables at compilation time. These variables memory is allocated and deallocated automatically when the program starts and ends. Variables declared outside of function or when using the `static` keyword fall into the category. Arrays *with a fixed size* also fall into this category. An example of a static memory allocation is as follows:

```C
// allocate the size of the array statically
int arr[10];
```
### Dynamic Memory Allocation

When you allocate memory dynamically you are doing so with pointers at runtime. This allows more flexible memory allocation because you can allocate memory based on the needs of the program. An example of dynamic memory allocation:

```C
// dynamically allocate the memory at runtime. This will contain garbage values
int *ptr = (int*) malloc(5 * sizeof(int));
```

You can use `calloc` to allocate memory for an array:

```C
// allocates memory for an array of 5 integers and initializes them to 0
int *ptr = (int*) calloc(5, sizeof(int));

// reallocates memory to store 10 integers
ptr = (int*) reallac(ptr, 10 * sizeof(int));
```

You can also use `realloc` to change the size of an already allocated memory section:

```C
// allocates memory for 5 integers
int *ptr = (int*) malloc(5 * sizeof(int));

//reallocates memory to store 10 integers
ptr = (int*) realloc(ptr, 10 * sizeof(int));
```

You always have to use `free` after you have allocated memory and are done with it:

```C
free(ptr);
ptr = NULL;
```
### Memory Segments

C memory is divided into multiple segments where you can allocate memory.

- Stack:
	- Local variables and functions
	- Automatically allocated and deallocated
	- Limited, too much memory used leads to stack overflows
- Heap
	- Dynamically allocated memory comes from here (`malloc`, `calloc`, `realloc`).
	- Heap memory is managed manually
	- No automatic reallocation can lead to memory leaks if `free()` isn't used.
- Global/Static Memory
	- Variables declared outside of any function and variables using the `static` keyword
	- Memory is allocated at compile time
### Possible Issues with Memory

- Memory Leaks
	- A memory leak is when dynamically allocated memory is not freed after it is no longer needed.

```C
// if we do not free the 'ptr' variable this will cause a memory leak
int* ptr = (int*) malloc(10, sizeof(int));
```

- **Dangling Pointers**:
	- A dangling pointer is when a declared pointer points to memory that has already been freed.

```C
// create a pointer
int *ptr = (int*) malloc(sizeof(int));

// free the pointer
free(ptr);

//reference the already freed pointer
// this is dangerous and will lead to undefined behavior
*ptr = 5
```

- **Double Free**
	- A double free is when `free()` is used more than once on the same pointer

```C
// create a pointer
int *ptr = (int*) malloc(sizeof(int));

// free the pointer
free(ptr);

// free it again
// this will cause undefined behavior, or crashes
free(ptr);
```

- **Wild Pointers**:
	- A wild pointer is an unitialized pointer. This means if you use a pointer before it has been assigned valid memory.

```C
// create a uninitialized pointer
// notice how we don't give it any memory
int *ptr;

// dereference the pointer
// this will lead to undefined behavior
*ptr = 10;
```
### Memory Allocation Cheatsheet

| Function    | Purpose                                                | Initialization               | Usage Example                               |
| ----------- | ------------------------------------------------------ | ---------------------------- | ------------------------------------------- |
| `malloc()`  | allocated memory dynamically.                          | No (contains garbage values) | `int *p = (int*) malloc(10 * sizeof(int));` |
| `calloc()`  | Allocates memory for an array and initializes to zero. | Yes (initialized to 0)       | `int *p (int*) calloc(10, sizeof(int));`    |
| `realloc()` | Resizes previously allocated memory                    | Preserves existing data      | `p = (int*) realloc(p, 20 * sizeof(int));`  |
| `free()`    | Free dynamically allocated memory                      | N/A                          | `free(p);`                                  |
## Directives and Macros

C provides preprocessed directives and macros that are processed before compilation begins. These allow developers to include files, define constants, and create conditional compiled code. This improves code organization, readability, and efficiency.
### Preprocessor Directives

These are lines in the code that start with `#`. They are instructions to the preprocessor that run before the compiler. Common types include:

- `#include`
	- Include a source file or header file. Header files are either *C Standard Library* or a user defined file.

```C
// SYNTAX: #include <header_file>

#include <stdio.h>     // system files use <file.h>

#include "myfile.h"    // user defined uses "file.h"
```

- `#define`
	- Define a macro or constant.

```C
// defining a constant
// SYNTAX: #define CONSTANT_NAME value
#define PI 3.14159
#define MAX_SIZE 100

// defining a macro
// SYNTAX: #define MACRO_NAME(params) expression
#define MULTI_MACRO(x)
  do {
    prinft("Value: %d", x);
    if (x > 2) {
      printf("Greater than 2");
    } else {
      printf("Less than 2");
    }
  } while (0)
```

- `#undef`
	- Undefine a macro. This macro must have already been defined using `#define`.

```C
// SYNTAX: #undef MACRO_NAME

// define the macro
#define PI 3.14159

// now undefine the above macro
#undef PI
```

- `ifdef` / `ifndef`
	- Conditional compilation based on whether a macro is defined or not. These are useful for platform specific code/debugging.

```C
// if the macro IS defined
#ifdef MACRO_NAME
  // perform whatever you need to do ONLY if the macro IS defined
#endif

// if the macro IS NOT defined
#ifndef
  // perform whatever you need to do ONLY if the macro IS NOT defined
#endif
```

- `#if / #elif / #else / #endif`
	- Conditional statement based on conditions. Allows more control over `#define`. Works like an `if/else` statement.

```C
#if CONDITION
  // perform action
#elif OTHER_CONDITION
  // perform other action
#else
  // perform another action
#endif
```
### Common Issues with Macros

Some common issues encountered with macros are:

- Lack of Type Safety

```C
#define SQR(x) (x * x)

// this will expand to 3+1 * 3+1 which is not what we are looking for
printf("%d", SQR(3+1));
```

- Unexpected side effects:

```C
#define DOUBLE(x) (x * x)
int a = 5;

// this expands to a++ + a++ which modifies the variable twice
printf("%d", DOUBLE(a++));
```

- Debugging difficulty
	- Since macros are replaced before compilation debugging issues related to macros can become extremely challenging.
### Directives and Macros Cheat Sheet

| Directive/Macro                      | Description                                                             |
| ------------------------------------ | ----------------------------------------------------------------------- |
| `#include`                           | Includes external files (header files)                                  |
| `#define`                            | Defines macros or constants                                             |
| `#undef`                             | Undefines a previously defined macro                                    |
| `#ifdef` / `#ifndef`                 | Conditional inclusion based on whether a macro is defined.              |
| `#if` / `#elif` / `#else` / `#endif` | Conditional compilation based on specific conditions.                   |
| `#pragma`                            | Provides special instructions to the compiler (compiler-specific).      |
| **Macros**                           | Preprocessor instructions that replace text or expressions in the code. |
## Debugging and Error Handling

Debugging and error handling are crucial for all developers, not just C developers. However, since there are no high-level
